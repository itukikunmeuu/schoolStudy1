プログラムの設計(オブジェクト指向設計)を勉強していると
「これ無駄じゃね？」と思うことが多々あります。

オブジェクト指向に限らず「設計」をおろそかにすると、
そんな無駄が些細にい思えるような無駄が出てきます。
(スーファミくらいの時代なら、確かに無駄でしたが...)

現代においては、リソースの無駄や二度手間三度手間の無駄を
省くためおよび、メモリリークのリスクの解消のために
無駄に思えるような設計をすることが多々あります。

FileManager->Fileを生み出す
多重ロード防止のために、内部に
map[ファイル名]=File;
のマップ(テーブル)を持っていて、すでにロードしている
ファイルの場合は、再ロードすることなくすでにあるハンドルを
もとに作ったFileオブジェクトを返す。

File(基底クラス) <l- ImageFile
File(基底クラス) <l- SoundFile

Deleteし忘れの防止
デストラクタからDelete処理を発行できるようにする。
これ単品なら簡単ですが...
→多重ロード防止のために、複数Fileで同じハンドルを使用しているため、
デストラクタでDeleteGraphしてしまうと
他が使っている画像まで消してしまう。

そこで、Fileの中にCount_という変数を用意しておいて
デストラクタのたびに、FileManager内になる元のファイルオブジェクトから
カウントを減らしていく。(ロード命令のたびに増える)

これがゼロになったら実際にDeleteGraphする。

今回はポリモーフィズムのためにマップ内のFileはshared_ptrで持っていますが、
使用者側に返す時にshared_ptrをそのまま渡すと、マップ内と、使用者側でおなじshared_ptrを
見ることになり、使用者側が消滅してもデストラクタが走りません。

なので、多少非効率ですが、このshared_ptrのコピーを作って、それを使用者側に返すようにします。
返す時に参照カウントをインクリメントしておきます。

こうすることで　、使用者が持っているのは使用者に所有権のある
Fileオブジェクトなので、使用者が消滅したり不要になった時にデストラクタが走ります。これによって、　
使用者が一人もいなくなったときにリソースが解放される。
という作りになります。

「参照」→ポインタのようでポインタでない、ちょっとポインタ
制約
①初期化時に参照先が決まっていないといけない
②後から参照先を変更できない
なので、メンバ変数に参照があった場合は、コンストラクタの初期化リストで「必ず」参照先が入る
と思ってください。

dynamic_castとは、ダウンキャストの時に使用するキャストである
通常、ポリモーフィズムによって、基底クラスとして扱うことは可能である
これを基底クラスになってしまったものを派生クラス(子クラス)の扱いに戻したい...そんな時に使用します。

File*file = new UnageFile;
これを後からImageFileとして扱いたい。通常のキャストやstatic_castでも、元に戻すこと自体は可能
imageFile* ifile=(ImageFile)file;//通る
ImageFile* ifile = static_cast<ImageFile*>file;

ただし、これらのキャストにはセキュリティ上の問題があります
例えば元ファイルが
File* sfile = new SoundFIle();
このようにImageFileでない場合でも
imageFile* ifile=(ImageFile)file;//通る
ImageFile* ifile = static_cast<ImageFile*>file;
通ってしまうだけでなく、iFileにはアドレスが入っています
つまり、中身が違うのに、あたかもImageFileのようなふりをして生き続ける
これはあぶない

それをぼうしするためにキャストがdynamic_castです
imageFile* ifile=(ImageFile)file;//通る
ImageFile* ifile = static_cast<ImageFile*>file;

ifileは元がImageFIぇのために、正常にImageFileに変換されアドレスが返ってくるが
isFileのほうyは元がSoundFileのため。変換が行われず
nullptrが買えてt来る

で、今回これを使おうと思ったが、内部にあるのはshared_ptrなので
denamic_castを使おうとすると、一度生ポインタをGet()などで取得する必要がある
これは面倒くさいし、危険です。

そこでdenamic_pointer_castを使います。これはsgared_preなどに対して
dynamic_castと同等にキャストを行うものです。

このコードに関して
return std::make_shared<ImageFile>(*imgFile)

何をしているのかというと、shared_ptr抜きで書くと
returen std;;make_shared<ImageFile>;
としているのと同じことです
で、new ImageFille(*imgFile)のブブに関してですがこれは
「コピーコンストラクタ」が呼ばれています。

コピーコンストラクタの定義はこうなっています。
クラス名(const クラス名&  コピー元オブジェクト)

コピー元オブジェクトは「参照」で渡されることに注意して下さい
*imgFileの*は、ポインタから三y層にするためにわざわざ実態に変換しています
これを行うことで、引数に渡されたオブジェクトの子ぴーができます。
→新しいアドレスに、元のオブジェクトのメモリがコピーされます。

　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
