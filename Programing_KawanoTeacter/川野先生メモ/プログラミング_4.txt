STL(stantard Template Library)
C++でTamplateというと、肩をいったん決めずに関数やクラスを作っておいて、利用時にその肩を決定するもの。

template <typename T>
T add(T 1va1,T rva1);

のように書くと「テンプレート関数」となり、呼び出しが書かれた時点で、その方のAdd関数が生成される。

tempate <typename T>
class Pointer{
	private:
		T*ptr_;
};
Pointer<Enemy> pEnemy;
のように、とあるクラスのメンバ変数の型がクラス利用する場面を書くまで確定しない。これが「テンプレートクラス」といいます。

で、このテンプレートの性質を利用して様々な便利なクラスや関数を提供してくれているのがSTLです。

代表的なものがvectorで、これは動的配列を表します。
動的配列とはそもそも何なのか？というと

int a[10];
これは固定配列です。10個しか入りません。
11個めを入れたくても、メモリを10個しか確保してないため、入れることができません。

☆実は通常の固定配列は安全そうに見えて、そんなに安全ではありません。
固定配列というのは、プログラムを書いた時点で、配列の大きさが決まってないと使えないものです。

→マップデータ(ステージのサイズが決まってない)
→ポリゴンデータ(頂点の数が読むまでわからん)

こういったときに便利なのが「動的配列」です。
動的配列を使用する方法はC/C++ではいろいろありますがもっとも簡単に使えるのがVectorです

int a[10];
はOKだけど
int a[rand()];
はだめ。ようは実行時までわからないから確保できない。値がわかってるものでしか使用することができないということ

それに対してvectorは
vector<int> a(rand());
でもOK。ようは指定された数だけ確保できる・

また、後からサイズを変更することもできて
a.resize(remainEnemies);

あと、なんだったら、お知りに一つだけ追加したい。
そんな時にも
a.push_back(要素);
という風に書くことができます。
もちろん普通に配列のようにも使えて

vector<int> a = {1,2,3,4,5};
みたいに最初から決まっている数字で初期化することもできます。

お仲間にmap,list,arrayなどがあります。
map : 連想配列
map<string,int> animals;
animals["dog"] = 3;
animals["cat"] = 5;
animals["rabbit"] = 7;

array : 固定配列
通常の配列よりも、セキュリティ面で優れている
array<int,4> a;
これはint4つ分の固定配列です。
意味的には
int b[4]
と全く同じです。しかし、
b[rand()];
は実行しエラーを起こしませんが
a[rand()];
の場合、範囲外になるとクラッシュします。(事故現場がわかりやすい)

arrayでもmapでも、vectorでも共通して便利な関数が使えます。
.size();//要素の数を得られる
.data();//[vectorとarrayのみ]
	配列のメモリアドレスを返す

listについては、ちょっと難しいので、わからなかったらいったん忘れていいです。

listはvectorと同じ働きをしますが、内部的なデータの持ち方が違います。
☆vectorはデータのメモリ上で連続しており、listはデータがメモリ上でばらばらである。

このことから、vectorはデータの検索が速く、またメモリをファイルに保存するときなどに便利。
ただし、要素の追加と削除が遅い。

それに対してlistは、メモリ上の連続性は問わないため要素の追加と削除のコストは安い、ただしデータの検索はvectorよりも遅い。
また、メモリ上でバラバラなのでセーブデータとして使うには不向き。
初心者に対するアドバイスとしては「listかvectorで迷ったらvectorでＯＫ」

stringの正体について...
stringは、C++において、文字列を表すものです。
STLの仲間です。
Cでいうと便利な文字列はchar*ですが、それよりもかなり便利な機能をたくさん持っています。

stringの関数
= : 代入
+,+= : 文字列の連結
==,!= : 比較(==だったら同じですよ)
length() : 長さを測る
find(文字) : 文字列中の文字の場所を返す
rfind(文字) : 文字列中の文字の場所を逆から返す。
substr(idx,[len]) : 文字列の一部を返す
c_str() : C言語の文字列として返す
　　DrawFormatString(x,y,色,"%s",str.c_str));
    なんていう使い方をします。

stringの本当の姿
string ≒ std:vector<char>
char型の動的配列に便利な関数を足しただけのもの
string str = "HelloWorld";
str[5] == 'W';
str.size() == str.length();
str.data() = 先頭のアドレス
☆str.resize(n)で文字列のサイズを変更できます。
　　場合によては、関数から文字列データを受け取る際に中身が空であってもメモリを確保する必要があります
　　(ファイルのロードとかWin関数とかそういったときにresizeを使います)

文字列(文字)について、歴史からお話しします。昔は日本語を使いませんでした。
この時代の文字セットをASCII文字列と言って、0～127の7ビットで文字が表現されていました。
この時代でも8bit使って、型方などは使えてました
　⇒半角カナ(半角ひらがながない原因)
きちんと日本語を使うために「マルチバイト」表現というのがでてきました。
日本語 : SJIS(Windows),EUC - JP(mac?)
これは、記号、英語、半角カナは1バイト、それ以外は２バイト以上で表現するものでした。

そのあとに「Unicode」というのができました。
バラバラだったものを統一しようぜ！となりました。
このunicode、統一されているはずなのですが実はUTF-8,UTF-16,UTF32などがあります(UTF-7も)
VisualC++ : デフォルト UTF-16
UTF32 : androidとか

ひとまず、大きなくくりとして
Unicode以前：マルチバイト文字列←char*で表現可能
Unicode以降：ワイド文字列←wChar_t*で表現可能

☆charとwchar_tは別の方なので、ごっちゃに使えない
"abcde"という文字列リテラルはchar*型です。
これにＬをつけて
Ｌ”abcde”と書くと、これはwchar_t*型です
実は、Dx_LIbの場合ないぶのまくろで　、プロジェクト設定によって、charとwchar_tを切り替えています

#elseif
~~~
~~~
~~
#endif
と書くと、ifとendif



DxLibを使う場合ｍ内部にTCHEARというマクロが設定されおり、プロジェクトの設定でUnicodeの時
TCHAR

ぷろじぇくとの設定に左右されたくない場合は
Ｌ”abcde”よりも_T("abcde")のほうがいいかもしれません
wchar_tとcharは別の型です。

で、先ほどstringを習いましたね？
stringにワイド文字バージョンはありますか。あります
それはwstringです。










