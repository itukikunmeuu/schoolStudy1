＜授業メモ＞
スマートポインタ
なぜスマートポインタを使うのか

スマートポインタとは、deleteを自動でやってくれる仕組み。
　（テンプレートの仕組みにより自動で解放される）
　例えば、shard_ptr<Monstre>monster(new Monster);
　で、このmonsterは変数としては「値型」ですが
　内部に元の生ポインタを持っていて、適切なときに開放する
　値型なので、もちろんスコープを外れると解放されますし
　誰かの持ち物の場合、持ち主が解放されると同時に開放される

　スマートポインタはこの仕組みをもっと強力にしたもの
　例えば、shared_ptrですが、これは内部に「参照カウンタ」を持っている
　
　で、ほかのスマートポインタに代入されたり、した場合には
　参照カウンタがインクリメントされます。
　ここまでが前提で、持ち主のshared_ptrがスコープを外れたり
　＝nullptrだとか、ほかのポインタを指し示す～のような操作を
　したときは参照カウンタをデクリメントします

　で、この「参照カウンタ」が0になったら誰も参照してない
　ということなので、そこで内部に持っている生ポインタをdeketeします

　～ここまではshare_ptrの話です～　

week_ptrは「参照カウントを上げないスマートポインタ」
　えっ？！そんなもん何の役に立つの？と思うと思います
　実はこいつに生ポインタは渡せません。
　じゃあ何ができるのかというと、shared_ptrを代入できます。
　代入といいつつ、実は、oparater=で代入以上のことをやってます。
　何をしているのかというと、shared_ptrの内部の参照カウンタを内部的に参照していて、監視しています。

　普通、shared_ptr同士で、代入＝操作を行うと参照カウンタは上がります。
　しかし、weak_ptrの場合は参照カウンタに変化はありません。

　なので、持ち主のshared_ptrがすべていなくなったら、weak_ptrが
　監視していても、中にあるポインタは解放されます。
　weak_ptrは参照カウンタを監視しているため、生きているか死んでるかを判別することができます。

　ただし、ここまでは「スマートポインタ？」って感じなので
　ポインタっぽくふるまうために「一時的にshared_ptrに変化できる」
　ような仕組みはあります

unipue_ptrとは
　これは「持ち主が一人だけのスマートポインタ」です
　⇒代入すると、持ち主の所有権を失います→中のポインタはnillptrになります
　基本的に参照カウントがあるとすると、常に0か1しかない
　そんなポインタです
　（あんまり使わないかな）

shared_ptrはポリモーフィズムおよびコンテナと相性がいい。
コンテナというのはvector.list.mapなどです。

例えば、モンスターの大軍をリストなどで管理するとします。
通常は、
std::vector<Monster>monsters;
と書きたいところですが、monsterが基底クラスとして純粋仮想関数を持っている場合は、そういう書き方はできません

基底クラスはそれそのものでは存在できない・・・
vector<monster>monsters;
なんて宣言すると
monster.resizse(100);
などと書いた場合、Monaterの実態を繕いうとして・・・でも
「お前純粋仮想クラスじゃん！実体作れねえよ！」
とエラーが起きます。もちろんpush_backでもできません。

じゃあ、どうするのかというと普通はポインタを使って
vector<Monster*>monster;
monsters.push_back(new Slime)
なんて書いたりします。しかしこれはもんだいがあります。
例えば、このスライムが死にました。で、魔王群から排除します。
vectorやlistの特定の要素を削除するには、erase関数を使います。
なおpop_backや、pop_front関数は、先頭要素、末尾要素を削除する。
eraseは特定の場所の要素を削除します「。どれを指定しても要素が削除されます。

ところが、
monsters.erase(it);//特定の場所の要素を削除
monsters.pop_back();//末尾の要素を削除
monsters.pop_front();//末尾の要素を削除
これらを用いても、内部にあるSlimeはメモリ上に残ったままです。

[0]⇒new Slime();
[1]⇒new Skelton();
[2]⇒new Dragon();

ここで三つ目のドラゴンを削除するためにpop_back()をした土地ます。
そうすると確かに
[0]⇒new Slime();
[1]⇒new Skelton();
こうなるのですが・・・
？⇒new Dragon();

なので、頻繁に生成されたり削除されるようなvectorやlistにおいては
deleteのかんりがとてもじゃないですが、できません。そこで
shared_ptrを使うと楽に管理ができます


ここまで強力なスマートポインタは、
#inclide<memory>
で使用できるようになります

std::make_shared<T>(new T);
は何を意味してるのかというと
std::shared_ptr<T>(newT);

「シーンをスタック構造で管理する」
シーンをSceneという基底クラスから派生して、それを切り替えるという
「stateパターン」を用いて管理しています。

これをもう一段階拡張して、特定のシーンにほかの特定のシーンを積んでいけるようにします。

今回は先ほども予告しましたがlistというのを使っていきます。
listはvectorのように、動的配列のように使えますし、ほぼほぼ操作も一緒です。

違いは、内部的なメモリの扱い方にあります。
vectorは「メモリが連続していることを保証」します
listが「メモリは連続していませんが、追加とｓカウ所のコストが安い」

今回はlistを使いますが、「どっちを使ったらいいかな」って迷ったら
vectorのほうで構いません。

出現：appear
退場：disappear

cpp側で
namespace{
  変数など
}
と書いた場合、これは「無名namespace」と言って、ほかのcppと名前がかぶらないようにするものです。

通常、変数の名前が同じものが、ほかのcppにあった場合、リンクしたときにエラーが発生します。
無名namespaceのカッコにくくられた変数は「このcpp内部でしか使わないよ」
ということで、しれっとコンパイル時に見えない印がついて、ほかのcppと同じ名前のものがあってもかぶらないようにできる。

シーンのpush,popをできるようにしますが、必ず一つはシーンが残るようにしておきます

コンテナ(listやvector)において
backというのは、末尾を示します
frontというのは、先頭を示します
　
push_back:末尾に追加
push_front:先頭に追加
pop_back:末尾を削除
pop_front:先頭を削除
front():先頭の要素への参照を取得
back():末尾の用をへの参照を取得

ゲームシーンにポーズシーンを積む
GamePlayingScene.cpp
①#include"PauseScene.h"
②P（ポーズシーン）



＜発言メモ＞
基本的にポインタは慣れるまではshared_ptrを使うのがよい



＜自主メモ＞




