「文字列型」

　マルチバイト文字：Shitf-JIS(SJIS)

　ワイド文字：Unicode(UTF-8)

　プロジェクトの設定をUnicodeにしても、Cppのテキストファイル

　の仕様そのものはSJISになっている

　マルチバイト文字：char*, string

　ワイド文字：wchar_t*, wstring

　これら相互の変換をするにはWindows関数を使う必要があります。

　MultiByteToWideCharという関数を使います。

	→ややこしいのは2回呼ぶ必要があります。

	この処理はゲーム作成の中でも何度か使うので

	自分の標準関数として作りましょう。

	自分のプロジェクトにStringUtilityというクラスを作って

	static関数ばかりのクラスはnewなどをする必要がない

	そういうクラスを作ります。

 

クラスのpublicメンバ関数には「必ず」コメントをつけましょう

publicメンバ関数を使うのは、利用者側です(自分ではない人が使う)

コメントはヘッダ側に書きましょう。

 

MicrosoftのAPIのマニュアルの読み方・・・

int MultiByteToWideChar(

  [in]            UINT                              CodePage,

  [in]            DWORD                             dwFlags,

  [in]            _In_NLS_string_(cbMultiByte)LPCCH lpMultiByteStr,

  [in]            int                               cbMultiByte,

  [out, optional] LPWSTR                            lpWideCharStr,

  [in]            int                               cchWideChar

);

 

[in]と書かれていたら普通のパラメータ(値が書き換えられない)

[out]と書かれてたら、ポインタを渡して書き換えられる事を期待します

[optional]は、この引数がなくてもいいよ(nullptrや0でも動作するよ)を表します。

UINT=Unsingned int

DWORD=uint32_t=4バイト符号なし整数型

LPCCH=LPはポインタの事、CCH=(const char型)→const char*を入れろ

LPWSTR=WSTRはワイド文字列のこと、それのポインタを入れろ

 

たぶん、いきなりこれを見て、理解できるかというと難しいと思います。

なので、理解できなくても構いませんが、とにかくMSのマニュアルを見る癖は付けて

おきましょう。

 

DxLibに文字列を渡す際は、たいていの場合char*やwchar_t*もしくはTCHAR*などの

ように文字列のアドレスを渡さなければなりません。なので、例えば

wstring wstr = "HelloWorld";

DrawString(x, y, wstr, 0xffffff);// ダメ。型が違う(wstring≠wchar_t*)

string::c_str()

wstring::c_str()

これらの関数は、stringやwstringをＣ言語の文字列(Char*やwchar_t*)に

変換します。

 

オブジェクト指向の三大要素

①カプセル化

②継承

③ポリモーフィズム

 

なぜカプセル化すのかというと、

　1.クラス内部の安全性を高めるため

　2.利用者側に対しての負担を軽減している

	公開情報を限定的にして利用しやすくする

		(利用者にとって不要な情報を見せない)

 

クラス(class)と構造体(struct)の違いは実は、デフォルトがprivateか

publicかの違いでしかない

classはデフォルトがprivate

structはデフォルトがpublic

 

継承→親子関係

　子は親の特徴を受け継いでいる

　子は親とis-aの関係である

　子は親のpublic属性とprotected属性にアクセスできる

　親にpublicで実装されているメンバ関数は子で実装しなくても

	子の関数として呼び出すことができる

 

親子関係の時にだけ意味を持つカプセル化属性として、protectedというのが

あります。これは、自分の子クラスには公開しますよ、というメンバに対して

指定する。

 

ポリモーフィズム(多態性)

　継承はis-aの関係であると話をしましたが、要は

　犬も「動物」

　猫も「動物」

　ウサギも「動物」

　ということで、全部「動物」と言えますよね？

　ポリモーフィズムとは、ぜんぶ「動物」として扱っちゃおう！

　という仕組みです。

 

　継承の考え方は下に向かって、どんどん派生していくという考え方でしたが

　ポリモーフィズムの考え方は逆に上に向かってどんどん抽象化(汎化)して

　行くという考えた方です。

 

　これが何の役に立つかというと、利用者側の処理を分けなくて済む


　このポリモーフィズムにつきものなのが、virtual指定子で、親の

　関数の先頭に付けることで、親の関数ではなく子の関数が呼ばれる

 

ポリモーフィズムとは、一言でいうと、より抽象的な概念としてまとめて扱える

ようにする仕組みです。

　それをするには親の関数にvirtualをつけることで、実際の動作は

　子に委託することができる。

 

　virutal 戻り値 関数名() = 0;

　という風に実装せず = 0と書くことで、自分は実装しない！という事を

　約束できる。この関数の事を「純粋仮想関数」といいます。

	ただし純粋仮想関数を持つクラスは単体で存在できません。

	継承して「子」としてオブジェクト化しないと存在できない。

	また、純粋仮想関数は「子で必ず実装しないといけません」

 

	という制約が生まれます

このようにポリモーフィズムは三大要素の中でもややこしいのですが、

いわゆるデザインパターンなどは、ポリモーフィズム前提で作られており

利用法が多岐に及ぶので身に着けておきましょう。

 

C++では、newで動的配列を確保することもできますが、解放がややこしいです。

int* a = new int[n];

で、動的配列を作れますが、これを開放するときは

delete a;

ではだめで

delete[] a;

と書く必要があります。

 

というわけでややこしいので、この授業では動的配列はすべてvectorを使います。

vector<int> a;

の場合、deleteしなくてもclear()するだけで、メモリは解放されますし、

スコープを抜けた時点で、自動的に解放されます。

 

 

 

 

 

 

 