[環境変数]を使うのか
1.PCごとに環境に左右されないため
        インストールフォルダなどにされないように
　　学校ではDxLibのフォルダはc:\DxLibだけど
　　家のフォルダは権限の関係上Cにはおけず
　　D:\名前\DxLibみたいになっている場合、家と学校でパスが違います
　　(ファイルが「どこ？」にある、という情報をパスといいます)
　　なので、環境変数を変えないと家でやる時と学校でやるときに
　　プロジェクトの設定をいちいち切り替えなきゃいけない、

　　☆パス(Path)について
　　　　1.exeやその他ファイルが置かれているフォルダのこと
　　　　　c:￥DxLib
　　　　2.フォルダを含めたファイル名
　　　　　c:\DxLib\DxLib.h
       ☆パスには絶対パス(フルパス)と相対パスがある
                  1.絶対パス(ドライブ名から続く指定)
	 　　　c:\DxLib\ライブラリに必要なファイル名\DxLib.h
	  2.相対パス(「現在のフォルダ」から見た場所）
                            main.cpp
                            cpp/ain.cpp
              ../main.cpp
              (..は一つのフォルダを示す）
環境変数として
　DxLib_DIR : c:\DxLib_VC~\プロジェクトに追加すべきファイル

環境変数
　　1.コマンドラインだったら％DXLIB_DIR%のように％で囲む
　　2.VisualStudioの場合は$(DXLIB_DIR)のように＄で囲む

　　VisualStudioの場合はデフォルトで独自の環境変数が
　　定義されていて
　　$(project)→プロジェクトファイルがあるフォルダ
　　$(outDir)→exeが出力するフォルダ

　　場所の確認
　　　　プロジェクトを立ち上げて
　　　　追加のファイルディレクトリなどに
　　　　$(projectDir)や$(OutDir)や$(DXLIB_DIR)などと書くと
　　　　「評価された値」という欄に、フルパスが表示されます

今回作るアプリケーションの設定をしていきます
　　1.パスの設定
　　　　c/c++→全般→追加のファイルディレクトリ
　　　　　　$(DXLIB_DIR)を書きます
　　　　リンカ→全般→追加のライブラリディレクトリ
　　　　　　$(DXLIB_DIR)を書きます
　　2.サブシステムの設定
　　　　OSがどのモードで、アプリケーションを起動するかを設定
　　　　→コンソールアプリとしてかWindowsアプリとしてか
　　　　　　i.コンソールアプリ→コマンドプロンプトから起動
　　　　　　ii.Windowsアプリ→Windowsから起動
　　　　コンソール(CONSOLE)
       Windows(WINDOWS)
　　　　のどちらかを「サブシステム」として設定します

　　　　CONSOLEからはmain関数が呼ばれ
　　　　WindowsからはWinMain関数が呼ばれます。

　　　　なんでそんなけったいなシステムになってるのか・・・
　　　　　実はコンピュータは、直接いじろうとするほど死ぬほど
　　　　　ややこしい
　　　　　メモリの話をすると、実は確保しているメモリは
　　　　　「仮想メモリ」と言って、ＯＳが使える領域を探してきて
　　　　　それを僕らが使いやすいように変換して渡している。

☆リンカエラーについて
　　リンカエラーが出たら大体この3つが原因です
　　　　①サブシステムとメイン関数の食い違い
　　　　　　　　CONSOLE→Main関数
　　　　　　　　WINDOWS→WinMain関数
　　　　②必要なライブラリの指定ができてない
　　　　　　　　「リンカー」→ライブラリ→追加ライブラリ指定が間違っている
　　　　　　　　ライブラリに指定がそもそもできていない
　　　　　　　　　　　#pragma comment(ライブラリ名,lib)
                     プロジェクトプロパティ→リンカ→追加のライブラリファイル
　　　　　　　　　　　にlibファイル名を置くと使えるようになる
　　　　③なぜか必要なcppがプロジェクトに含まれていない

	④使っている関数の実装がどこにもない

コンパイルとリンク
　　コンパイル:●●.cpp⇒●●.objに変換すること
　　リンク:●●.objや××.objや■■.libを一つにまとめてexeにすること

　　ヘッダー:関数などの本体を持っておらず、名前と引数の型を押してるためのカタログを置いている
　　obj/lib:関数の本体が記述されている

Debug/Releseについて
Debug：デバッグしやすい代わりに遅い(余計な情報が含まれている)
そもそも遅いので相手のPCで思った速度が出ないかもしれない

ただしデバッグはDebugモードでやりましょう

デバッグに役立つ話
　　1.まずはブレークポイントの使い方を覚えましょう
　　　　ブレークポイントで中断すると「ローカル」にその時のローカル変数が表示されてるので、おかしな値を見つけれれる。
　　　　加えて「出力」をみると、何かが失敗したときはDxLibがログをはいてくれるのでそこにも注目しておく
　　2.中断したところから、F10で１行1行実行していく
　　　　ただし、Releseモードでは有効ではありません
　　　　理由は二つあります
　　　　　　一つは、デバッグ情報がないため関数名も値もがわからない
　　　　　　もう一つは、プログラムが順番に実行されません
　　3.F11で関数の中に入っていく（自作の関数:ライブラリの中には入れない）
　　4.デバッグカーソルは実はドラッグして移動できます
　　5.ブレーク中に変数にマウスポインタを合わせると、中の値を見れます
　　6.5の値はクリックして、値の変更が可能です
　　7.ブレークポイントで右クリックして、条件を追加することができる
　　　条件を満たしたときのみ、処理を中断する。
　　8.データブレークポイントというものもあります。
　　　→特定のメモリの内容が書き換わったら中断
　　　一度実行を始めてからじゃないと、メモリの番地が確定しないため
　　　実行中でないと設置できない
　　　⇒プログラムのどこで内容を書き換えてるのかがわからない
　　　　特にメモリ破壊の時などは、その変数自体をいじってないのにいじられていることがある
　　　　そういう場合には、データブレークポイントが有効です。
　　9.あと、呼び出し履歴も活用しましょう。これはブレークしたところを呼び出した件数をさかのぼるように参照できる。
　　　また、呼び出した時点での周囲の変数の内容も参照できる
　　　　　⇒関数本体は正しくても呼び出し側が間違っている
　　　　　

プログラムの注意点
Warningがあってもプログラムは動きますが、できるだけ減らしましょう。
MainやWinMainも関数なので、戻り値が必要です。
0：正常終了
-1：異常終了

対処のしづらさランキング
1.実行はできるし、クラッシュもしない、でも動作はおかしい
2.ある程度実行して動作するけど、ある時クラッシュする。
3.リンカエラー
4.コンパイルエラー

1番についてですが、これはプロでも悩みの種です。
→まちがってるときは、人為的にでも一刻も早くクラッシュさせよう
Debugのときは、積極的にクラッシュさせて
Releseのときはクラッシュさせないように

それをやるのが...assert関数です

クラッシュしたときに、慌てて「中止」を押さないでください。
なぜか「再試行」を押してください

中止すると、プログラム自体の実行自体が終了し、状況がわからなくなる、
再試行すると、クラッシュの時点でブレークして、周囲の状況を確認できる
無視はダメ

assertという関数があり
#include<assert>
で使えるようになります。この関数は
assert(条件式)
この条件式の中身が真(true)の時以外つまり偽(false)の時に人為的クラッシュを発生させます

何のためにこんな関数があるかというと、早め早めにバグの原因を突き止めるためです。


バグではないが「明らかに間違ってる状況」に対して、クラッシュを起こすために使います。

配列で
int a[10];

この時
a[7] = 7[a] = *(a + 7)
です
実は、配列の名前というのは配列のために確保されたメモリのアドレスを入れている変数です。
つまりポインタと同じ。
ここで注意点...
ここでいう+7は、7バイトのことではない。
コンパイルされた時点でaがint(4バイトとわかってるので)
+7⇒+7*4＝+28に変換されます。僕らに見えないところで。

その結果7番目の要素を返している...ということになります。

ついでに2次元配列についてですが
2次元配列は1次元配列です








　　