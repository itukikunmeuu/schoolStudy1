コメントの書き方
	原則として「意図」を書くようにする
	意図というのは「なぜそのコードを書いたのか」がわかるように

	i++;//iをインクリメント　×

	i++;//配列のインデックスを順次巡回するため　◎

☆コメントにうそを書かないようにしてください
　⇒プログラムがアップデートしたら、コメントも見直しましょう。

基本的にはコメントの書き方は自由ですが、クラス宣言側のpublic関数だけは「必ず」コメントを入れましょう。
関数の上で///書くと、関数説明のお手本のようなものが自動生成されますので、それに従ってコメントを書きましょう。

基本的にwinsowsのAPIに関しては、必ず最終的にはMicrosoft公式のリファレンスを読みましょう。ぶっちゃけ難しいです。意味が分からなくてもいいので、一回は目を問いしておきましょう、そのうち慣れます。

わかりやすい説明をしてるサイトも多いのですが、場合によってはうそを書いている可能性があります。

標準の特殊な方の書き方
基本的には数字がビット数を表していると思ってください。
先頭にuがついているものは、符号なし(unsigned)を表しています


　uint32_t a; : 32bit符号なし整数型
　int32_t a; :　32bit符号なし整数型
　uint16_t a; : 16bit符号なし整数型
　int16_t a; :　16bit符号なし整数型
　uint8_t a; :　8bit符号なし整数型
　int8_t a; :　8bit符号なし整数型
  byte g;:　byte符号なし整数型

今日やること
①Applicationシングルトンクラスを作る
②時間が足りればstateパターンによるシーン遷移を作る

シングルトン(Singleton)クラスとは何か...
	アプリケーションの中で一つしかインスタンスがないことを保証するクラス
	どこからでもこのインスタンスにアクセスできる
　シングルトンクラスとは「お行儀の問いグローバルオブジェクト」である。

　「インスタンス」　：　メモリを確保して作った実体(メモリを食いつぶしてる)
　static関数
　ローカルstatic変数:ふつうはローカル変数は関数を抜けるとともに
	解放されますが、static変数は削除されません
	アプリケーションが終わるまで存在し続ける

シングルトンクラスの作り方
	コンストラクタをprivateに置くことで、オブジェクトを同的に生成できないようにする。
	Apprication app;//×
	Apprication* app=new Aoorication();//×
	Apprication& app=Apprication::GetInstance();//ok
	Apprication app=Apprication::GetInstance();//通るけどダメ
なぜだめなのか、これは別のアドレスにコピーができちゃってる。
コピーコンストラクタというのが悪さしている。

クラスを作ると
①暗黙のコンストラクタ&デストラクタが生成されている
②暗黙のコピーコンストラクタも生成されている。

普通のコンストラクタ
クラス名();
コピーコンストラクタ
クラス名(const クラス名& )

演算子オーバーロードとは...＝+-*/を再定義するものです。
戻り値　operator演算子(右辺値);

今回のように、オブジェクトからオブジェクトへの代入を禁止したいなら、void operator(const クラス名&);
をprivateに置くようにします。

さらに、もっと徹底するなら、private云々よりも、使えなくします
クラス名(const クラス名&) = delete;
void operator(const クラス名&) = delete;
とやることで、この名前のインスタンスは保証される。

シーン遷移について...
	タイトル画面→ゲーム中→ゲームオーバー→最初に
	という具合に、場面によって表示も入力対する応答も変わる。
	この一つ一つの場面のことを「シーンと」いいます

で、今回はひとまず、3つのシーン「タイトル」「ゲーム中」「ゲームオーバー」を切り替えられるようにしようと思います。

そこで使うテクニックとしては「stateパターン」というのを使います。
ぽりもーふぃずむを使用して、「現在のシーン」を次から次へ切り替えてタイトル→ゲーム中⇒ゲームオーバーを遷移したいと思います

もしかしたら今まではシーンの切り替えをゲーム管理クラスや関数内のswitch文で切り替えてたかもしれませんが、このパターンでは、それぞれのシーンが次のシーンへの切り替えを制御します。

初期化リスト(初期化子)について...
クラスのメンバ変数の初期化は基本的にコンストラクタ内で行いますが
複雑ではない変数の初期化であれば
クラス名：：クラス名(引数)　：　メンバ変数(初期価値){}

のようにして、面板数を初期化できます。なお、C++のしようとして、メンバ変数はこの方法で初期化することが推奨されている。

また、メンバ変数が参照や、constの倍は、ここで初期化せざるを得ない

固定配列もなるべくSTLを使おう
char Keystate[256];
これもSTLを使うと
std::array<char,256> KeyState;

今回はそれぞれのシーンを常態とみなして切り替えていくというプログラムを書きました。
SceneManagerクラスに「現在実行中のシーン」を指し示すポインタを持たせておいて、それを各シーンが切り替えられるようにしました。

SceneManagerはUpdate関数とDraw関数を持っていて、それぞれ現在実行中のシーンのUpdate関数とDraw関数を呼び出しています。

どういう条件で次にどのシーンに宇遷移するかどうかは各シーン自身が知っている。これによりシーンマネージャーは現在実行中のシーンも知らなくていいしｍ次度のシーンに遷移すべきかも知らなくていい。

知っているのは、実行中のシーン時死因の実です。
これはポリモーフィズムを使用したパターンです。現在のシーンがどうであろう宇都利用者側からは考慮しなくていい、どうさわそれぞれのしーんがわかってるため。

今回はいわゆる生ポインタを使っていきましたが、先ほどちょっとトラブったように解放し忘れが発生します











