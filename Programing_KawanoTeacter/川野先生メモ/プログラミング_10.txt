テンプレートの仕組みを使って実装されています

shared_ptr<ポインタとして扱いたい型>p;
のようにして宣言します

これでpはポインタのように働いてくれます

p->◎◎
で、メンバを使えますし
*ｐ
で、そのアドレスの値を取得できます
これを実現しているのは内部でoparatorオーバーロードしているからです

で内部に「参照カウンタ」を持っているため、だれも持ち主がいなくなった時点で元のポインタが保持するメモリの内容は解放されます

→解放忘れを防ぐことができます。

解放忘れをするとメモリリークが起こって、非常にまずい状態になる。

気を付けていればdelete忘れは防げるのですが、ポリモーフィズムだのlistだのmapだのと組み合わせて使った場合、どの時点で参照が外れるのかの管理が非常～～～に大変なので、もうここは最初に覚えておいて活用していきましょう

通常であれば
T*p = new T(引数)
と書いていたところを
shared_ptr<T> p=make_shared<T>(引数);
と書いて使用します。

今回はまず、Sceneのポインタをshared_ptrに変更しました
Sceneはシーン切り替えのたびに中身が切り替わるため、、自分で管理するとdeleteのタイミングなどが非常に面倒になってきます

こういった場合にshared_ptrは使用する。
(基本的にはもう、外部のライブラリとの連携とかでやむをえない場合を除いて、生ポインタT* p = new T() を使わない)

※極論を言うと、newもdeleteも自分のコードの中にはないようにしましょう。

ポリモーフィズムを利用するような場面ではポインタはつきものですが、
そういうところにshared_ptrを活用しましょう。

shared_ptrを使っておけば、ポインタをlistやvectorの中に格納している場合でも、個別にdeleteの必要はなく、要素の削除や、list,vectorそのものがスコープ外に出たときに自動で、参照カウンタが減り0になってくれれば安全に開放されます

listにpushやpopの関数があります。std::listは双方向リストなので、先頭にも末尾にもpushができます。
先頭:push_front
末尾:push_back
で要素の追加と削除を行います。今回は末尾への追加と削除を行い
それによって、シーンのスタック構造を実現しています。

今回のシーン構造の場合、ステータス更新と描画の関数を分けています。
理由は
①ステータス更新は末尾のシーンだけを実行
②描画はすべて実行

ポーズ時も、ゲーム画面の描画を行いたいため、描画はすべて実行しています。

DxLibの2DDraw系の関数は「後ろから描いた絵が上からどんどん描画される」仕組みのため、描画順が、例えばゲーム中のポーズの場合

ゲーム本編描画⇒ポーズ画面描画
とすべきです

そうなると、範囲for文を使う場合、これは順番にしか実行されないため
これを見越して、ポーズなどの積んでいくシーンは末尾に積んでいます。

listでもvectorでもmapでも「要素が一つもない時」を表す関数として
empty()
があります。これで要素があるのかないのかを判別します

入力の話
「皆さんが作るゲームはパッド対応してほしい」
よくあるのが、キーボードしか対応してません。ですが遊ぶ側としては、パッドに対応してほしいと思います

で、パッドの内容は
GetJyoPadInputState
を使って取得しますが、この中の
DX_INPUT_KEY_PAD1
はあまり使わないでほしい。こいつをつかうとキーボードはともかく
パッドとの対応が固定されてしまいます。

パッドにはいろいろと種類があって。
PS系のパッド　
Xbox系のパッド
それ以外。があります。

DX_INPUT_KEY_PAD1の問題点は、最初っからキーボードと
PADの対応が固定されている・・・これをチェックすると
Zキー＝INPUT_Z　＝　ショルダーとか？
Xキー = INPUT_X = STARTボタンとか？

のようになっており、非常に対応させづらい・・・

そこで
入力と実際のゲーム内の操作の間にワンクッション置きます

UnrealEngineは入力を直視しているのではなく、あらかじめ
「入力」と「ゲーム中の意味」の対応表を作っています

"Shot"というイベントを定義します
ゲーム中はこのshotイベントが飛んできたら球を打つように設計します

UE4では「プロジェクト設定で」
"shot"というイベントが発生するようになっています。

次に使うのは「std::map」です
mapというのはいわゆる「連想配列」です
どういうものかというと普通の配列なら
int a = {1,3,5,7,9};

a[0] = 1;
a[3] = 7;
ですが、これをたとえば「文字列」を添え字として使うことができます。

std::map<string,int> pets;
pets["いぬ"]=5;
pets["ねこ"]=3;
pets["うさぎ"]=2;
pets["ペンギン"]=4; 
等のように管理することができます。
mapを理解するために外せない話があります。それが
std::pair<T1,T2>です。
これは何派というと、2つの型の値を2つ保持する型です。
ただ単に、型の違う値を2つもてるものです。

std::pair<string,int>pr;

pr.first = "動物"
pr.second = 15;

要は内部にfirstとsecondという要素を持っていて、それぞれ別の型で管理されたのを一つにまとめているだけの型です。

なぜその話をしたのかというと、std::mapというのはstd::pairの集合体だからです
基本的にたくさんのpairを集めて「ツリー構造」という検索しやすい高z層で集めています。

で、oparatpr[](T1&key)などを実装してｍあたかも連想配列のように使うことができるのが、mapです。
一つ一つはpairでできていて、それを集合体だと思ってください

mapというのは「データベース」のやくわりを果たします。
データベースというのは「キー(識別するためのもの)」を与えると
その中にあるデータを返す仕組みです。

mapの場合は、その中にあるpairのfirstがキーとなっていて
データがsecondに当たります。

なので、一覧を取得したい場合は
map<string,int>table;
//データを入れていく(中略)

で、一覧を見たいときは
for(pair<string,int>&data : table){
   cout << data.first << endl;//キーに当たる
　  cout << data.second << endl;//値(データ)に当たる
｝

あと、ちょっと気を付けておいてほしいのが...
int a=table["ハムスター"];
とやると、クラッシュせずに、何事もなかったかのように
table["ハムスター"]=0;
のようにデフォルトの値を入力します
つまりtable["ハムスター"]が左辺値だろいうと右辺値だろいうと
データベースに含まれていなければ、新しい行を追加してしまう

このため
int GetValue(const std::map<std::string,int>&table,const char* str){return tavlr[str]}

この関数はエラーを起こしまsう。何がまずいのかというと、tableがconstなので
table[str]というぶんそのものがconst制を破壊するからです
(中のデータが「増える」化の知れないからです。データの参照だけというわけにはいかないのです。呼び出し側は内容を把握しているかもしれませんが、この関数内では、何が「キー」としてくるのかわからない状態です。だからエラーが出ます。)

これに対処するためにこれまたややこしい仕組みを使います。
ここで出てくるのが「イテレータ」です

イテレータというのは「ポインタの用でポインタではない、でもちょっとポインタ」

例えば
std::vector<int> a = {1,3,5,7,9};
//std::vector<int>::iterator it
auto it = a.brgin();//最初の要素のイテレータを返す

ここでitは最初の要素の「位置」を刺さしめしています。
なので中身を知りたければ

cout << *it << endl;
と書く必要があります。

で、じゃあこの場合、a.end()は何を指し示しているでしょうか
これは末尾の要素のお尻を刺し占めしています。
なので、*a.end()などと書いても値がないため、クラッシュします。

じゃあなんでこんなものがあるのか・・・というと
「ここで配列なり、連想配列なりリストが終わりですよ！」というのを指し示すためだけに存在する。

vectorやmapにはat(添え字)という関係があります。
table.at("ハムスター")
は、一応const制を守ってくれますが、ない要素を与えられるとassertを起こします。
at(index)自体は「index」と同じ意味ですが、「ない要素」を入れるとクラッシュする関数です。

プログラム用語でtableというと、これは「表」を表します。表というのはデータベースのテーブル(キーから取得できる構造)だと思ってください。







＝先生発言＝
oparatorオーバーロードとは
T*で戻り値のconstの変更がいいのかだめなのかを示す
oparator-> constのポイントの変更のいいのかだめなのかを示す


constは参照は了承される値の変更は了承されない。

iteratorはポインタの振りをしようとしているなにか

begin->初めのところ　end->終わりのその先で値がない
（end = 最後の値ということではないよ。　上記の場合9ではないということ）

＝自主勉強＝
アロー演算子　ー＞の形　※後で検索する必要有

GetJotPadInputStateの意味
パッドの状態を得る。キーボード入力の際の簡単に押したときに動かしたりの処理ができるもの。

イテレータとは
配列のようなデータ構造尾の要素を順に走査していく繰り返し処理を簡潔に記述できる構文やオブジェクトなどのこと




















