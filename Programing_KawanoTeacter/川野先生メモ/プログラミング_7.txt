/*授業ノート*/
ポリモーフィズムとは
継承したクラス群を親クラスとみなすことができる
Scene <|--　TitleScene
Scene <|--  GamePlayingScene
Scene <|--  GameoverScene

状態遷移:とある状態から、次の状態へ、特定の条件で遷移する ※条件を満たしたときにSceneを移動させるみたいなもの

この状態と、繊維条件を特定のクラスだけで管理するのはちょっと大変なので、それぞれの状態を自身に遷移をコントロールさせる。

初期化リスト(初期化子)というのがあって

コンストラクタ(パラメータ):メンバ変数1(値),メンバ変数2(値)と書くことでそれぞれのメンバ変数を初期化することができます。
この部分での初期化は、メンバ変数のアドレス確定と同時に見放されるため、const変数や、&参照などの初期化に使われます。

ここで注意点は親クラスのconstや&参照のメンバの初期化を子クラスで直接行うことはできない
→なので、初期化リストでは親クラスの引数付きコンストラクタを呼び出すことで、constや&参照の中身を決定します。
子クラスコンストラクタ():親クラスコンストラクタ(引数)

シングルトンクラス(singleton)
→アプリケーション中に、そのクラスのインスタンスが一つしかないといいうクラス
補償すべきことはそのクラスが一つしかないということ
(これを保証できないならシングルトンとは言えない)
シングルトンは、言い換えると「お行儀のいいグローバル変数」です

作り方:コンストラクタをprivateします。
これによって、他人がそのインスタンスを生成することができなくなります。
それだけでは、使用できなくなってしまうだけのなので、インスタンスを作成し、そこにアクセスできるようにします

static変数、static関数とは...
宣言した時点で、アドレスが確定しているものです。
なので、staticメンバ関数はクラスオブジェクトが生成されてなくても呼び出すことができますし、static変数は宣言した時点でアドレスが確定しているため、スコープを抜けても居座り続けますし、何度参照しても、同じアドレスを見ている←グローバル変数と同じ

今回は、Application::GetInstance関数でstaticオブジェクトへの参照を取得するようにしています。
ここで注意点ですが「参照」じゃないといけません

なのでGetInstance関数の戻り値も参照ですし
Application& Application::GetInstance()

呼び出し側も
auto& app = Application::GetInstance();
のように、参照型で受け取らないといけません

Application　application = Application::GetInstance();
としてはダメですよ、こうすると何がまずいかというとApplicationの実態が複数になってしまいます。

①Application::GetInstance()関数内のstatic変数
②Application applicationの時点で、別の場所にメモリが確保され、そこにApplicationの実態が生成されている

なのでApplication application = Application::GetInstance();
これは許してはいけません。

ところが、実は見えない部分に「コピーコンストラクタ」という関数ができていて、そいつが勝手のpubkic側に置かれているため
特に対処をしなければこのコードは通っちゃうのです。

なので、これを防止するためにApplicationクラス側では明示的にコピーコンストラクタを宣言して、これをprivateに置きます。
もっと徹底するなら、代入演算子オーバーロードもprivateに置きます。
さらに徹底するならこれらの関数の後ろにdeleteをつけ、絶対に呼べないようにします

コピーコンストラクタにはこのような宣言になります。
クラス名(const クラス名& ref)

これを禁止します
private:
	クラス名(const クラス名&) = delete
これでもう、GetInstance()関数内のstatic変数以外に存在を許せなくなります。

usingについて
いろいろ使い方が多岐にわたるので、覚えるのが大変な尾ですが
ひとまず知っておいてほしいのが「別名」の作成です。

例えば
std::unroderd_map<std::string,std::vector<Monster*>>
こういう型を使わなきゃいけない時があります。
何度かくのは面倒だし、ぱっとわかりづらい。こういった場合にusingで別名を作ります。

using MonsterTable_t=std::unorderd_map<std::string,std::vector<Monster*>>;
こうすれば後は

MonsterTable_t monsterTable1;
MonsterTable_t monsterTable2;
MonsterTable_t monsterTable3;

メンバ関数ポインタの時にも役に立ちます
class c{
  void (Monster::*Updateunc_)(Input& input);
};
これ実はUpdateFunc_がメンバ変数に当たるのですがわかりづらい。
そこで、
class c{
  using UpdateFunc_t = void(Monster::*)(Input& input);
  UpdateFunc_t updateFunc_;
};

そういうわけでusingは可読性を上げるために結構使います

あとはusingがよくつかわれるのが
using namespace std;
のように、「今から書く関数の先頭にはstd::つけてるかもよ～」
というルールを作ったりもします。

☆using namespaceはヘッダーでは書かないでください
using namespaceの影響範囲は、using namespaceより下の行すべてであるため。

#include "◎.h"
というのは実は、◎◎.hの内容をそのまま#includeの行にコピーしてるだけです。このため、下手にヘッダ側でusing namespaceを行うと
想定外の影響範囲に及んで把握できなくなってしまいますので、using namespace stdなどはcppでやるようにしましょう。

::はスコープ解決演算子と言って、名前空間やメンバ変数などを明示的に示すために使います。

namespace myprogram
{
	class Player
	{
		publib:
			static Func();
	}	
}

この中のFuncを呼び出すたじゃったら
myprograming::Player::Func();
のように呼び出します

シーンの中の状態遷移(状態遷移の中の状態遷移)
メンバ関数ポインタによる状態遷移をやってみましょう

メンバ関数ポインタとは何ぞや：メンバ関数を指し示せるようなポインタ。
　☆関数も実はアドレスを持っています。で、関数ポインタは
	そのアドレスと格納している変数です
　そのアドレスを「呼び出す」ということをすれば、関数が実行されます。
　実は関数というのは、特定のアドレスにジャンプすることを示しています。そのアドレスを格納するポインタを切り替えていくことで、
　実行される関数を切り替えることができます。
　
　要は今の更新関数を切り替えることで様々な状態を維持したり
　切り替えたりできます
ただし、メンバ関数ポインタは文法がちょっとややこしいです
①まず宣言：戻り値(クラス名::*ポインタ変数名)(引数)
②次に代入:ポインタ変数 = &クラス名::状態関数名;
③最後に実行:（this ->* ポインタ変数）(引数);

状態遷移にはいくつかの方法があって
①stateパターンで、現在実行中にクラスを切り替える
②メンバ関数ポインタで、現在実行中の関数を切り替える
③これらでにっちもさっちもいかない場合にはswitch文でも何でも使おう！

4つのキャストについて
static_cast<型名>(元の変数):いわゆる普通のキャスト
 float f= 3.14f
 int oyoso = static_cast<int>(f);
dynamic_cast<型名>(元の変数)：ポリモーフィズムを使ってるときに適切な子クラスの型に変換する。
　変換できない場合はnullptrを返す・

static_castは、特にnullptrを返さずに、変換できちゃう
　⇒不具合の温床になる
dynamic_caseはアウトの時にnullptrを返すため変換できない場合はすぐにわかる。
↑基本的なcastはこれをお勧めします。



/*先生の発言*/
マクロ等では先頭に_をつけるものがあるため、最近ではお尻に_をつけることが多くなっている。
だがコーディング規約は会社によっては、様々なコーディング規約があるのでコーディング規約は各々のプロジェクトや会社によって臨機応変に対応していく

演算子オーバーロード(オペレーターオーバーロード)
演算子である%&/*-+などをオーバーロードできるということ(かなり簡単に言うとだね)

ヘッダーにusing namespaceを書くとメモリ圧迫になったり無駄な処理、スタックが起こってしまう可能性が高いためcpp cs cに書く

this　自分自身のインスタンス。　メンバ関数ポインタ呼ぶときは必須

/*自主*/
std ：　namespaceなどで使われる変数。配列ではないけどそんな感じやね
0xffff　：　bitの中身のようなもの。16bitとかの値等で使用されることがある　
nullptr : オブジェクトのハンドルだったり、ポインタが示されているのかの判断をする関数
シングルトンクラス(追加)　：　自身のインスタンスを静的フィールドに保持しているもの

