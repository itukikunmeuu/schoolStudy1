＜授業ノート＞
デバックのために
ログを記録しましょう。

DxLibに限らず、windowsAPIのプログラムにおいては
「出力」に、ログを出力したい。こういった要望があります。

ただし、ログ出力の関数OutPutDebugStringには、フォーマット命令がないです。

じゃあどうするのか...？

2種類の「文字列に対するフォーマット」を行う仕組みがあります。

Ｃ言語的には。
Sprintf();
があります。(ただし、セキュリティの都合上、sprintf_sを使うことになります。)

これは、メモリ領域に、フォーマット済みの文字列を書き込む関数です。
sprintf(メモリ領域のアドレス、"フォーマット文字列",パラメータ);
を使います。ただし、セキュリティレベルの問題でerrorができることがあります。
その場合はsprintf_sを使用します。
sprintf(メモリ領域のアドレス、バイト数、"フォーマット文字列",パラメータ);
で、指定のメモリ領域に、フォーマット済みの文字列が記述されます。

C++言語的には
stringstreamというのを使ったりします。
ストリームをいう概念は、可変長との書き込みに可能な領域に文字列などを書き込む
それを「流れ(stream)」と表現して、そこに必要なものを書き込んでいく仕組みがある。

対象がファイルの場合は「ファイルストリーム」だし、可変長文字列の場合は
「文字列ストリーム」といいます。
なんで「流れ」なのかというと、イメージ的には流れている川に物を投げて次から
次へ流れていくイメージです。流れは文字列などを流すことで流れが生まれます。

すでに皆さん、この「ストリーム」の仕組みは見ています。何か。

cout<<"Hello World" << 256 << "," << 3.14 << endl;
これは「標準ストリーム(コマンドラインのこと)」に流している。ということを意味します。

このストリームの指定にフォーマットをつけたいとします。
これがＣ言語のsprintfに比べると、ちょっとややこしいです。
マニピュレータというのを使うことになります。

マニピュレータを使うには、iomanipをインクルードします。

%を使いこなそう
小学校以来出番がなかった、「割ったあまり」ですが、実はプログラミングにおいては
めちゃくちゃ出番があります。実は高校より先の数学でも結構出てきます。

%演算(剰余演算)は、面白い特徴があるため、様々なことに利用されます。
①数値の範囲を制限する、本来0～65535の間のランダムな値を10～30に限定したい
　そんな時に使えます。割ったあまりなので、
　例えば、rand()%10と書くと、10になった瞬間0になるため、数値は0～9の範囲に限定される。
　例えば、10～30の間に限定したい場合は0の時に10になり最大値が30になるように10+rand()%(20+1)となります
rand()%(20+1)の取りうる範囲が0～20になります。もし+1がないと
範囲が0～19になるため注意しましょう。この0～20に+10しているため、
範囲は10～30になります。これを一般化して、a~bの範囲内に乱数を収めたい場合int v = a+rand()%(b - a + 1);
とやれば乱数をa~bの範囲に収めることができます。

②周期性を持ちます。割ったあまりなので、
frame%10の場合、0,1,2,3,4,5,6,7,8,9,0,1,2,3...のように、剰余演算の右辺値になった瞬間0にもどるため、この演算は「周期性を持つ」といえます
例えば、アナログ時計などは1+n%12といえます(nが時間ごとに増える)
これを利用して、同じことを繰り返させたり、アニメーションなどに利用できる。

実はこれを形であらわすと「のこぎり形」になっていますこれを変形して
山型にもすることができます。周期をmとすると

abs((n%2m)-m)
のような式を書けば、山形に動くようになります。これを用いれば、
1.真ん中が明るい画像
2.if文を使わずに「往復」させることができます。

ちなみに、%演算のことを日本語では剰余演算と言って、
英語ではModuloといいます。カタカナではモジュロといって
関数も用意されています。ModとかfModとか...

この周期性を利用して、最後に移動したものがまた先頭から出てくる
という「ループ」的な動きを実現できます。

もし配列のようなものを一つ一つ移動するものを作ろうとする
終端でさらにその先を要求されたらまた先頭に戻る

次に進む場合は
void Next(){
  index = (index + 1) % size();
}

ただし、この時「前に戻る」の場合がちょっとややこしい
precious 内容のサムネ的なものを事前に見せる
previous 「前の」を意味して、Nextの逆

void Previous(){
  index = (index - 1)%size();
}
ではうまくいきません。なぜかというと、%演算はマイナスに対応していません

この場合、
a=m%n
b=(m+n)%n

a==b

これを使用します。
m=0の場合
a=0%n=0
b=(0+n)%n=n%n=0

n>5,m=5

a=5%m=5;

n=7,m=5

a=5%7=5;//7が0個分と残り5
b=(5+7)%7=12%7=7 一個分と残り5
になります

つまり、%演算の左側に剰余と同じ値を足しても同じ結果になります。これを利用すると-1に対応できます。
n=7 m=-1
a=-1%7=未定義動作→期待した動作をしない
b=(-1+7)%7=6=最大値。つまり最低値より前に行ったときに最大値になり、マイナス方向もループさせることができます

値xをnの倍数にしたい場合

例：16の倍数にしたい
0,1,2,3...16..........32,33
0,16,16...,16,32,.....32,48

3を16にしたかったら、13を足せばいい

(16-3)%16+3=16

(16-x%16)%16+x

x=15
(16-15%16)%16+15=16

x=16
(16-16%16)%16+16=16

x=17
(16-17%16)%16+17=(16-1)%16+17=15+17=32

(16-x)%16+x

(16-16)%16+16
-32%16+32=?

xをmの倍数にしたい場合は
val=(n-x%m)%n+1

トグル(Toggle)
キーボードのボタンは、おっすと元に戻りますが
古い扇風機のボタンの場合、弱とは中とか強を押すと
ボタンがおしっぱ状態になって戻らなくなる


先生発言
std::hexを使う際はstd::decも活用して元に戻してあげる
std::hex→16進数に変換する
std::dec→16進数から元の進数に戻してあげる
