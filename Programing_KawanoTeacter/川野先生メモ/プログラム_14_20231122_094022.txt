テキストファイル→人間が読みやすいもの：txt,csx,xml,json
バイナリファイル→コンピュータが読みやすいもの：bmp,doc,png,mv1

人間は
1234
という数字を見て、千二百三十四という風に、数値として判断します。
ところがコンピュータは
「'1'2'3'4'という文字が並んでいるだけ」という風にしか解釈できません。

atoi→文字列を整数値にする
中でやってることは、整数の文字列が渡されたという前提で
何文字あるかを最初にとっておく(今回4桁)そして、最初の文字がその桁である
ことがわかる
1*1000+
2*100+
3*10+
4*1

この結果、数値としての1234が出てきます。
この「数値としての1234」を数値として保存した場合
1234ではなくメ・みたいな文字列として保存されます
人間が見てもよくわからないデータですが、これをコンピュータが読み取ると
1234が復元される。。

ただし、これをコンピュータが1234のような適切な形式に復元するには条件があります。
これはデータの「読み方」がわかっていることです。

「読み方」とは何かというと「型」のことです。型というのは、サイズと「解釈」を持っているものだと考えてください

データ1234567890を文字列として解釈してしますとメ蜂になりますし。
floatと解釈すると122890.250になります。つまり、解釈次第では全く別の

データになってしまいます。
つまり、バイナリデータというのは、データと「解釈」が必要であると考えてください。
読んだ結果、どういうデータとして解釈するのかがわかってないと使い物にならない。
→ある意味セキュリティにいなっています

作った人間はデータの型前伊の意味を知っているので、解釈がわかる。
それ以外の人間は、データの塊の意味、解釈を知らないのでただのごみになる。

セーブデータをバイナリ化するメリット
①セキュリティがテキストより高い
②コンピュータが読みやすい形式なので、場合によっては構造体と指定ペンに
	読み込めてしまう
	
struct Header{
	char signarure[4];
	float version;
	size_t size;
};
こういう風に固定のデータになっている場合はいっぺんに読み込める。
また、テキストデータと違って、atoiなどで解釈しなおす必要がないため早い

③大体データサイズが小さくなる。
	整数の1234567890は4バイトに収まります。
	(16進数の場合は2桁が1バイトです)16進数の場合は0～ff(255)→１バイト
	これをテキストファイルにすると当然10バイトになります
	1 2 3 4 5 6 7 8 9 0 →10文字...１０バイト
	
例：RPGデータをJSONでやろうとしてた。
	問題
	①セキュリティが弱い(ユーザが簡単に書き換え可能)
	②JSONをC++で読もうとすると、難しいしめんどくさい→実装に時間がかかる。
	③読み込み速度が低下する(サイズが大きい+字句解析)
	気持ちはわからんでもない...
		バイナリは自分で作るのが大変...
		①自分でツールを作る
		②C++のコード内で直接データを記述して、それを外部データとして出力する
		③データのコンバータを作る→テキストをバイナリに変換する
		
文字列の扱いはC++よりC#のほうが強い
	C++って文字列の扱いがそれほど上手じゃない(ライブラリが充実してない)
	C++が扱いやすいようにデータをC#で作ってあげるというのはよくやります。
	
今回はキーコンフィグのセーブとロードを作りましたが
ゲームアプリ中でセーブとロードを行っているため、やってることはほぼ同じです。

セーブは「書き込み」でロードは「読み込み」の関数使うだけです。

データ出力をプログラムするときは、同時に「データの読み込みをする側」のことも
考えながらデータを決めていきましょう。
読み込むときに事前に知っておくべき情報は必ず先に入れておく。
全部が固定のデータなら、そんなことを考える必要はないんですが、
今回のように、データが固定長とは限らない。そんなことを考える必要はないのですが。
今回のように、データが固定長とは限らない。そんな場合には「データの数」や
文字列のサイズも必要になります。

例えば文字列
"abcde"
を書き込んだとします。素直に書き込むと
abcde\0
になりますが、これを読み込みの時のことを考えてください。
どこで文字列が終わるか「読み込むまでわからない」ので、読み込むときの
サイズがわからないままReadすることになる。バッファオーバーランも起こすかも
1バイト1バイトを1つずつ読んでいくのは遅い。
"abcde"を書き込むときは
5abcdeみたいなデータにしておく
先頭1バイトを文字列として扱う

ループが必要な部分は基本的に「最初にサイズを書き込んでおく」

次は「ファイルマネージャ」を作っていきたいと思います
①多重ロードの防止
②Delete(Graph,Sound)し忘れの防止
③最後に残ったりそーしを削除するように

リソース→画像、サウンド、データのような外部データすべて
		→ゲームエンジンでは「アセット」ということが多い
		
①unorderd_mapを使用→多重ロード防止
②デストラクタを使用→Deleteし忘れを防止
	デストラクタで削除しようとすると、本体がunoedered_mapに入っているので
	アプリ終了時にしか削除されない	
③unordered_mapに残ったものをすべて削除する。

今回はポリモーフィズム鵜を使います。このため、unordered_mapの中身は
基底クラスであるFileクラスですが、中身はImageFileだったり
SoundFileだったりする仕様です。

最終的にデストラクタでマネージャ側に「消された」命令を飛ばしますが、
この時の関数がImageFileとSoundFileで異なる
dynamic_castとは...

static_castとは、Ｃ言語の普通のキャストと同じです。

dynamic_castとは
File*file=new ImageFile()
はできますよね?

これはfileとしては扱えますが、ImageFileとしてはもう扱えません。
この時に、派生クラスであるImageFileとして扱うためにdynamic_cast
を使います

ImageFile* img=dynamic_cast<ImageFile*>(file);

File* sfile=new SoundFile();//アップキャスト(暗黙のキャスト)
ImageFile* img = static_cast<ImageFile*>(sfile);//通っちゃう
ImageFile* img = dynamic_cast<ImageFile*>(sfile);//nullptrが返る

親クラス→派生クラスのキャストを「ダウンキャスト」といいますが
このダウンキャストを安全に行うために
dynamic_castとは、ダウンキャストできない方変形の場合にnullptrを返す
(static_castだとアドレスを返しちゃう)

return std::make_shared<ImageFile>(*imgFile);

まずmake_sharedについてですが、これは

shared_ptr<ImageFile>img(new ImageFile());
こういうことをしているのと同じことだと思ってください。
つまり、内部でnewをして、それをshared_ptrに渡せる形にして
返している

ということは
returun std::make_shared<ImageFile>(*imgFile);
は
return std::shared_ptr<ImageFile>(new ImageFile(*imgFile));
と同じことです
となると、まず疑問は

new ImageFIle(*imgFile)
ですが、これなんでしょ...？

コピーコンストラクタというのがあります。これは、ほかのオブジェクトを
もとにして、「別のアドレスの」オブジェクトを作るものです。
まさにコピーというわけです。

File* file = new File();
File* file2=file;//これではfileとfile2はどういつである。
					//同一アドレスを見てるので、file2の変更は
					//fileにも反映されてしまう。
もし、やりたいのが、fileと同じものを作りはするが
場合にコピーコンストラクタを使う

この場合
File* file3 = new File(*file);
とすると、fileの内容はまんまfile3にコピーされるが、中身的には別のアドレスを指している

で、コピーコンストラクタの定義は

クラス();//これが通常のコンストラクタ
クラス名(const クラス名&コピー元)；//これがコピーコンストラクタです

上のコードのように、元のオブジェクトを「参照」で渡しているため
ポインタを渡してはダメ...というわけです。そこで*をつけて実体化した
上で渡すことによって、参照扱いになり、コピーコンストラクタが発動する

shared_ptr<File>file
で、これをdynamic_castしたいときには、dynamic_castはshared_ptrを
とれない(生ポインタしか使えないため)、get()関数で生ポインタを取得して
denamic_castしています。
例えば、こいつをshared_ptr<ImageFile>にダウンキャスト

shared_ptr<>






