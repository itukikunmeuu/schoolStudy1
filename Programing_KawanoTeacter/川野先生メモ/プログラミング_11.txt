授業メモ
＜就職の話＞
行きたい会社は持っておいたほうがいい
　方向性だけでも緩く決めておきましょう。
　全然方向性が違うところに行くと落とされやすいです。
　自分の会社に合う人材が欲しいので

プランB、プランC用意しておきましょう。
　どんなに優秀で、どんなにいいやつでも落ちるときは落ちます。
　この全手で、2～3社落ちても絶望しないようにしましょう。

それはそうとして、「どういう人材が欲しいのは」は知っておきたいですよね？
　とはいえ、特に新卒の募集ページではあんまり具体的なことは書いてないです。
　じゃあどこを見るのか...

　中途採用のページも見てください
　　①具体的に欲しい人材が書かれていることが多いです。
　　②実際のお仕事が予測できるようなことが書かれています

　その会社の技術発信のページを見ておきましょう(過去のCEDECの講演とか)
　　①中で何を研究しているのかがわかる。
　　②技術情報を得られる。
　　③「発信を見てます」ということを伝えられる。
　　　理解できなくてもいいです。


unorderd_map:マップと同じです。
マップは、並び替えが行われます。unoederd_mapは並び替えが行われません。
mapの場合、キーが文字列の場合は、確定でa<b<c,1<2<3の法則で並び替えれれます。
underderd_mapの場合は、この並び替えが発生しません。

mapは自動(50音順だのなんだの)でソートされる
unoederd_mapは並び替えられません(とはいえ登録した順番でもないので注意)

mapは見つけやすいようにツリー構造になっている
unorderd_mapは、ハッシュ値をもとに並べている。(ツリー構造ではない)

速度的に言うと
unorder_mapのほうが検索が速いです(追加と削除も)

機能的にはmapと全く同じなので(並び方が違うだけ)、気にせず使ってOKです。

データ構造における「入れ子構造」

struct Position{
 float x,y;
};

class Player{
 Position pos;
 flaot life;
}
プレイヤーの中にポジションが入ってるという考え方

これは納得しやすいかなと思いますが、mapやvectorの要素に関してもこれと同じことができます。

map<string,map<string,vector<int>>> //入れ子構造の派生版のようなもの
mapの中にstring,mapに入ってそれにstring,vectorを入れているという考え方でok

map(unorderd_mapも同じ)はpair<T1,T2>の集合体です
pair<T1,T2>とはなにか、これは二つの型を組み合わせたもの。

template<typename T1,T2>
struct Pair{
 T1 first;
 T2 second;
};

Pair<string int>->
struct Pair{
 string first;　//キー
 int second;　//値
};

mapはこれの集合体です。

mapやunorderd_mapは連想配列

std::map<string,int>animalTable;
animalTable["rabbit"]=15;
みたいに使えます。これを連想配列といいます。
連想配列とは、配列の添え字が数値じゃなくて文字列などを使えることです

ただし、この連想配列的な扱い方は注意が必要です。
それは、
animelTable["rabbit"]
を描いた時点で、もし"rabbit"が存在していない場合
animalTableに”rabbit”要素が追加されてしまいます。
「中の値を参照したいだけ」という意図はプログラムに伝わりません。

つまり、連動配列としての使い方はconst関数やconst引数においては使えません。

メンバ関数の後ろにconstがつくと、メンバ変数の値の変更ができなくなります。値を読み取り専用で見ることだけが、許されます。

mapにはfind巻子が存在して、中身をキーで検索します。
あればその「イテレータ」を返し、なければmap::end()を返します。

で、at関数というものがあり、これは[""]と同様に
中の該当の要素を返すための関数

もし、中に”cat”があるとしたら
animalTable["cat"]==animalTable.at("cat")
となります。
ただし、中に要素がない場合は
["~"]の場合は、新規に追加され
at("~")の場合は、クラッシュします。なので、atの場合は
実質、「ない要素」の追加ができません。
これを逆に言うと、const制を維持しているとも言えます。


animalTable["rabbit"]はconst関数内では使えませんが
animelTable.at("rabbit")はconst関数内で使えます。

マルチワイド文字(普通のcharとかstring)
ワイド文字(wchar_tとかwstringとか)

で、そもそもプロジェクト設定→詳細→文字セット
の指定における
①マルチバイト
②unicode
の違いは何なのか...？これは、実は内部でUNICODEというマクロがdefineされるかどうかを表します

①#define UNICODEがない
②#define UNICODEがある

その結果
①TCHAR char
②TCHAR wchar_t

DrawString系は文字列をTCHARで扱っているため、プロジェクトの設定によって、そもそもの型が変わっちゃう。しかし、それ以外の部分は実は影響を受けてないため、もしマルチバイトの設定でやってる人は
DrawFirmatStringには、stringのc_str()をそのまま入れてください。

Unicodeにしている人はwstringに変換してください。
もしかしたら「いやこれ、マルチバイトにしたら解決じゃない？」と思われるかもしれませんが、実は、そうもいかなくて、この変な話は「文字列リテラル」にしか通用しません。

つまり、ロードした文字には全く適応されません。
リテラルというのは、プログラム文中に書いた文字列"abcde"のことです。
しかし、ゲームにおけるたいていの文字列は、プログラム文中にあるものではありません。

warningに関して。
warningは本来無視していいものではありません。無視してもコンパイルは通りますが、危険だということを示しています。
企業にプログラムを提出した際に、warningが表示されていると評価が下がります。

基本的には、全warningをつぶすようなプログラミングをしてほしい、
ただし、場合によっては「使用しているライブラリ側」がwarningを引き起こしていることがあり余す。このwarningがあまりにも多いと、本来つぶすべきwarningが見えずらくなってします。

なので、そういうwarningが得的で来たら、それだけ無視するということを行います
たとえば今先生のPCではDxLib側でwarning C4819というのが連発しています。
これはプログラムのコードページが違うために出てる←どうしようもない。
これは無視したい。この無視したい番号4819を覚えておいて

プロジェクトの設定でC/C++→詳細設定→特定の警告を無効にする
ここに4819を書き込みます。そうするとwarningが消えますが、これは今回のようなやむを得ない場合にだけ使ってください。本来まずい警告を消すためには使わないでください。

DrawFormatString
printf
などの、書式指定について...
%d   =  10進数で数値を表示する。
%c  = 文字を表示する
%s   = 文字列を表示する
%f = 浮動小数手を表示する

整数型に関しては
%d : 10進数
%x  : 16進数
%o : 8進数

さらに桁をそろえることも可能
%4d : 10進数
%4x  : 16進数
%4o : 8進数
などとすると、４桁に揃えられ、空いた部分には空白が入る
%04d : 10進数
%04x  : 16進数
%04o : 8進数
と書くと、空いた部分に0が入ります。

floatも％2.2ｆなどとかくことによって、小数点以下の桁数を
そろえることもできます。

　
　


発言メモ
＜就職関係＞
大体行く場所がどの会社なのかなとある程度絞っておいたほうがいい
(かわいい系統なのか、かっこいい系なのか、ジャンルは何がいいのか)
方向性だけは決めといたほうがいいと思うけどがちがちには決めないほうがいい。
実力が足りていても落ちる。面接した人との相性があるのでしかたない。
落ちた時のプランBをもっておくのが必要。

会社が落ちたからダメなのかという感じではなく引き抜きもある。
行って戻ってがあったりもする(最終的にもいける可能性がある。)



自主勉強