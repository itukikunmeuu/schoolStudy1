2023年9月27日
・プログラム中で書かれる型とメモリの関係について
僕らが解釈する数値と、メモリ上においてある値は必ずしも一致しません。
型には2つの意味があります。
　①「メモリ上の値をどう解釈するのか」
　②「その方そのものがどれくらいのメモリを食いつぶすか」

人間はメモリ上にあるデータをそのままるかうことができない。
　⇒データおよび「解釈(ビュー)」とセットでやっと使い物になる

「参照」について
ポインタみたいなもの。←指示してるのはアドレス
ただし、ポインタよりも使いやすくできていて、普通に*や->をつけなくても、普通の「値変数」と同様に使えます。

int b = 12;
int & = a = b;
こうすると、aはbと同じ場所を指示しているため、
b++;
と書くと、aも13となり、さらにa++と書くとbも14になります・

参照のルール(ポインタと同じ役割ですがポインタよりもルールが厳しい)
　①宣言時にどこを参照するかが決まってないとダメ。
	(例外的にコンストラクタの初期化リストは許される)
	int & a; //だめ
　②参照先の変更はできません。
	int & a = b;
	a = c;//これは、cの値をaにコピーしているだけ。

参照とポインタどっちを使えばいいの？
　☆参照のほうがいい場合
　①初期化時に参照先のアドレスが確定している場合
　②参照先を最後まで変更しないことを保証できる場合

Union(共用体)について
共用体とは、要素それぞれが同じメモリを共有して使う型です。
めったに目にする方ではないですが、ハードに近い部分や古いコードではよく出てきます(メモリの内容をけちるため)

c++的な「型」について
　std::vector<std::string>これも一つの「型」です。
　クラスと同じような扱いです。

型と値のコピーについて
通常、同じ型同士の＝演算は値のコピーが行われます。
ここでいう値のコピーはメモリの内容をそっくりそのまま相手にコピーします。

int a[4] = {1.2.3.4};
 int b[4];
 b = a;//なぜだめなのか

これはaが差し市示しているのは配列の先頭アドレスで
それをbにコピーしようとしている。つまり、アドレスの値をコピー使用しています。

さらにこれがダメな理由は、配列は宣言した時点でアドレスが固定されます。
つまりアドレス自体がconstなのです。
constであるアドレスを変更しようとしているため文法エラーが起きます。

int* c = a;//ok

で、ここでvectorについてですが
　std::vector<int> a = {1,2,3,4,5};
　std::vector<int> b;
　b = a;

これは、実はキチンとメモリの内容がコピーされます。
配列と違って、アドレスの受け渡しではなく内容がちゃんとコピーされます。つまり構造体のような挙動になりますが・・

実は=で代入していますが、これはvectorの中に定義されている
=演算子オーバーロードが内部でメモリをコピーしてくれています。



c++の中にはSTLというのがあります。
この中でよく使用する型として
std::vector<T>
std::map<Key,Value>
があります。
std::vector<T>は動的配列を表現します。
動的配列というのは、固定長の配列と違って後から配列のサイズを変更できるものです。

Ｔと書いた部分に、動的配列の要素の型を入れることでＴ型の、動的配列を作ることができます。

std::vector<int> ←int型の動的配列
std::vector<float>　←float型の動的配列

int a[4];
a = {1,2,3,4,5}; //ダメ

vector<int> b = {1,2,3,4};
b.push_back(5);
b = {1,2,3,4,5};//OK

なぜこんな動的配列が必要なのか・・・
通常の配列は配列の要素数が最初から決まってるときにしか適用できない。

ゲーム開始時点では、ステージの広さがわからない。
ステージデータをロードして初めてステージの広さがわかる。
そんな場合があります。そうして場合はマップデータを後から拡張しないといけません→固定配列では力不足。
そんな時に動的配列を使用します。


☆ゲーム用のTips
関数に「配列や構造体やvector」を渡す際は、できるだけ参照渡しにしましょう。

なぜか
引数で渡す場合は、意味合い的には引数の型
変数名＝引数;と書いているのと同じです。int や floatならせいぜい4バイトなので、このコストはそんなに大きくありません。

ところが構造体の場合はたいてい16バイトとは32バイトとは何だったら、512バイトや、もっと言うと何KBになったりします。
これの何がまずいのか・・・

関数を呼び出すたびに、構造体のサイズ分のメモリが確保されてしまい、さらに、メモリのコピーが発生します。
1～2回なら問題なのですが、例えば3D座標の受け渡しなどは、ループ内で10000回とか発生します。
そうなると、512バイトのコピーは5120000バイトのコピーコストになります。

なお、アプリケーションの処理の重さに影響を与える順番で書くと
ロード＞＞メモリの確保・解放 = メモリの内容のコピー > それ以外の演算
→原則的には、関数に構造体(8バイトを超える内容のもの)は参照私にしよう。
ただし、ただの参照渡しだと副作用があるため関数内部で引数の値を書き換えられないようにconst参照にしよう

c++では、「保証する」という考え方が非常に大事で、そのために参照引数をconstにしたり、関数のお尻にconstをつけたりします。
こうすることで、参照引数は、内部で書き換えられないことを保証し、
const関数は、メンバ関数内部でメンバ変数の内容を書き換えないことを保証します。

autoについて...c#のvarみたいなもの
普通、変数を宣言するとこには、intやfloatなどを指定します。
もし、右辺値から「型」を推測可能な場合には、intやfloatではなく
autoと書けば、型をコンパイラが推測して自動でintやfloatにしてくれます
このことから、autoを使うと、右辺値の型さえ確定していれば全部autoでOK
なんでautoみたいなのがあるかというと、プログラムを書いてるうちに、
「あ、これfloatのほうがいいな、全部変えよう」みたいなときに、変更箇所が増えます。
変更箇所が増えるとバグが増えます。

なので型事態を右辺値に決めさせようという思想の中から生まれました。

☆autoの注意点
思った型になってないこともあるので、慣れないうちは変数にカーソルを合わせて、型名を確認しよう
autoといっても、型はコンパイル時に保存されますので
auto a = 5;
a = 3.14f;
とするとaは整数型のままなので、a = 3になってしまいます。

autoは&などを引き継ぎませんので、参照として扱いたい場合は
auto & a = b;
とします。例えば、
int c = 3;
auto& b = c; //bはcへの参照になります
auto a = b;//aはただのbへのコピーになります
この場合、aはただの値なので、cやbの内容とは独立します。
よくあるのが
for(auto e : array)
{
++e;
}
この場合、もとになった配列の内容は書き換えられません。
autoを使ってほしい部分...
右辺値が確実に存在する場合
　①後で型が変わりそうな場合
　②型の名前がやたら長い時std::vectorM<std::string>
　③型がやたらとややこしい時←関数ポインタなど
	関数ポインタは宣言がvoid(*f)(引数)みたいにややこしいので
	auto使ったほうが見栄えもいい
charとwchar_tは明確に違う
プロジェクト→プロパティ→全般→文字セット
①マルチバイト→char*がデフォルト文字列を表す
②Unicode→wchar_t*がデフォルト文字列を表す

①の時は
LoadGraph("●●.png");
とかでいい
②の時は
LoadGraph(L"●●.png");
としなければならない
文字列には、通常小野文字とワイド文字の二種類があります
通常の文字列リテラルは、char*で表せる”ダブルクオートでおｋ”
ワイド文字列リテラルは、wchar_tで表せれるＬ””のようにＬが頭に必要です










