内積ってご存じ
A(a,b,c)
B(d,e,f)

A・B=ad+be+cf
計算方法は、次元数分「かけて足す」

A・A = lAl²
A・A =a*a+b*b-c*c =lAl


Bomb構造体が、いくつもあるような状態を作る
アニメーションが終了したら、勝手に死ぬ
そういう仕組みに作りたい
std::list<Bomb>bombs_;
いくつもあるので、リストで管理(生成と消滅が頻繁にあるので)

ラムダ式について...
→その場で作れる「無名関数オブジェクト」

ラムダ式の定義...
最小ラムダ式は
[](){};

なんですけど、それぞれ意味があります。
[]はクロージャ、キャプチャ(束縛)と言ってちょっとややこしい概念
	なので、今回は使いませんが、文法上[]が必要だと思ってください
()は普通に引数を表します。もしint pなんていう引数が必要なら
(int p)と書きます

{}は関数の中身、実態を書きます。中で何をするのか...を書きます
｛printf ("Hello World")｝と書けば、このラムダしきっはHelloWorldを出力する無名関数となります。
クロー社[]の部分ですが、このむめいかんすうをつくったときの周りの状況を記憶しておくためのものです
[変数]
だと、その時の変数を記憶しておきます
[&変数]
だと、その時の変数の参照を記憶しておきます。
[=]
だと、その時の周囲の変数すべてをw記憶しておきます(少し危険)
[&]
だと、その時の周囲の変数の参照をすべて記憶しておきます
[this]
だと、その時の持ち主のクラスのポインタを記憶しておきます

で、このラムダ式、何が便利なのかというと、関数内で関数を定義したり、ramove_ifなど
のif系の関数のPrend(ifへ結果を返す関数)として使うことができます

list.remove_if:ifに合致する要素だけを削除する関数です
この関数の引数として要求されているのが関数オブジェクトです。
とはいえ、自前で作るのは面倒案オデ、ラムダ式を使用します・

list.remove_if([](引数){
			return 消す条件(true/false);
			});
引数ですが、listなどのコンテナの場合、一つ一つの型を引数にすればいい
list<string>names;だった場合

仮に、名前が2文字以下の名前のみ削除したいならこうします
list.remove_if([](const string&bane){
				return name.length() <= 2;
				});
				
この場合、クロージャについては考慮しなくていいです。

2Dの場合、XとYを入れ替えて、片方をマイナスにすると90°回転と同じことになります
(-y,xの場合)
(1,0)->(0,1)->(-1,0)->(0,-1)
で、なんでこうなるのか...

回転を表す行列というのがあって
lsin - coslxl=xcosΘ-ysinΘ
lsin   coslyl xsinΘ+ycosΘ
Θ=90だとすると
cos90=0
sin90=1

lcos90 - sin90lxl=-y
lcos90   sin80lyl=-x


